#!/bin/bash
# Interactive TUI-style notmuch search viewer for Evolution

# Store terminal dimensions
TERM_HEIGHT=$(tput lines)
TERM_WIDTH=$(tput cols)
PAGE_SIZE=$((TERM_HEIGHT - 5))
CURRENT_POS=0
TOTAL_RESULTS=0

# Handle terminal resize
handle_resize() {
  TERM_HEIGHT=$(tput lines)
  TERM_WIDTH=$(tput cols)
  PAGE_SIZE=$((TERM_HEIGHT - 5))
  full_redraw=true
  draw_results
}
trap handle_resize WINCH

# Draw the results screen
draw_results() {
  if [ "$full_redraw" = true ]; then
    clear
    if [ -f "$LOADING_COMPLETE_FILE" ]; then
      printf "Search results for '%s' (j/k to navigate, gg/G to jump, Enter to open, q to quit):\n\n" "$QUERY"
    else
      printf "Loading results for '%s' (j/k to navigate, gg/G to jump, Enter to open, q to quit/cancel):\n\n" "$QUERY"
    fi
    
    # Calculate slice of results to show
    START_IDX=$((CURRENT_POS - CURRENT_POS % PAGE_SIZE))
    END_IDX=$((START_IDX + PAGE_SIZE - 1))
    [[ $END_IDX -ge $TOTAL_RESULTS ]] && END_IDX=$((TOTAL_RESULTS - 1))
    
    # Display all visible results
    for i in $(seq $START_IDX $END_IDX); do
      # Calculate available width for text (accounting for the prefix "XX. ")
      AVAILABLE_WIDTH=$((TERM_WIDTH - 4))
      TEXT="${DISPLAY_TEXTS[i]}"
      
      # Truncate text if needed and add ellipsis
      if [ ${#TEXT} -gt $AVAILABLE_WIDTH ]; then
        TEXT="${TEXT:0:$((AVAILABLE_WIDTH-1))}…"
      fi
      
      if [ "$i" -eq "$CURRENT_POS" ]; then
        tput rev
        printf "%2d. %s\n" $((i+1)) "$TEXT"
        tput sgr0
      else
        printf "%2d. %s\n" $((i+1)) "$TEXT"
      fi
    done
    
    # Show pagination info with loading indicator if still loading
    if [ -f "$LOADING_COMPLETE_FILE" ]; then
      printf "\nShowing %d-%d of %d results\n" $((START_IDX+1)) $((END_IDX+1)) "$TOTAL_RESULTS"
    else
      printf "\nShowing %d-%d of %d results (loading...)\n" $((START_IDX+1)) $((END_IDX+1)) "$TOTAL_RESULTS"
    fi
  else
    # Just update the highlighted lines
    START_IDX=$((CURRENT_POS - CURRENT_POS % PAGE_SIZE))
    
    # Unhighlight previous position
    if [ -n "$prev_pos" ] && [ "$prev_pos" -ge "$START_IDX" ] && [ "$prev_pos" -lt $((START_IDX + PAGE_SIZE)) ]; then
      # Calculate available width for text
      AVAILABLE_WIDTH=$((TERM_WIDTH - 4))
      TEXT="${DISPLAY_TEXTS[prev_pos]}"
      
      # Truncate text if needed and add ellipsis
      if [ ${#TEXT} -gt $AVAILABLE_WIDTH ]; then
        TEXT="${TEXT:0:$((AVAILABLE_WIDTH-1))}…"
      fi
      
      tput cup $((2 + prev_pos - START_IDX)) 0
      printf "%2d. %s" $((prev_pos+1)) "$TEXT"
      tput el
    fi
    
    # Highlight current position
    # Calculate available width for text
    AVAILABLE_WIDTH=$((TERM_WIDTH - 4))
    TEXT="${DISPLAY_TEXTS[CURRENT_POS]}"
    
    # Truncate text if needed and add ellipsis
    if [ ${#TEXT} -gt $AVAILABLE_WIDTH ]; then
      TEXT="${TEXT:0:$((AVAILABLE_WIDTH-1))}…"
    fi
    
    tput cup $((2 + CURRENT_POS - START_IDX)) 0
    tput rev
    printf "%2d. %s" $((CURRENT_POS+1)) "$TEXT"
    tput el
    tput sgr0
  fi
}

# Main loop for user interaction
# Clean up function to remove temporary files on exit
cleanup() {
  rm -rf "$TEMP_DIR"
}
trap cleanup EXIT

main_loop() {
  full_redraw=true
  draw_results
  while true; do
    # Use a timeout with read to allow system to sleep
    # This makes the script yield control periodically
    # If no key was pressed (timeout occurred), continue the loop
    if ! read -rsn1 -t 1 key; then
      continue
    fi
    
    case "$key" in
      j)  # Move down
          if [ $CURRENT_POS -lt $((TOTAL_RESULTS - 1)) ]; then
            prev_pos=$CURRENT_POS
            CURRENT_POS=$((CURRENT_POS + 1))
            # Check if we need to redraw the whole page
            if [ $((CURRENT_POS / PAGE_SIZE)) -ne $((prev_pos / PAGE_SIZE)) ]; then
              full_redraw=true
            else
              full_redraw=false
            fi
            draw_results
          fi
          ;;
      k)  # Move up
          if [ $CURRENT_POS -gt 0 ]; then
            prev_pos=$CURRENT_POS
            CURRENT_POS=$((CURRENT_POS - 1))
            # Check if we need to redraw the whole page
            if [ $((CURRENT_POS / PAGE_SIZE)) -ne $((prev_pos / PAGE_SIZE)) ]; then
              full_redraw=true
            else
              full_redraw=false
            fi
            draw_results
          fi
          ;;
      G)  # Go to last result
          prev_pos=$CURRENT_POS
          CURRENT_POS=$((TOTAL_RESULTS - 1))
          # Check if we need to redraw the whole page
          if [ $((CURRENT_POS / PAGE_SIZE)) -ne $((prev_pos / PAGE_SIZE)) ]; then
            full_redraw=true
          else
            full_redraw=false
          fi
          draw_results
          ;;
      g)  # First part of 'gg' command or just 'g'
          # Wait for another key press
          read -rsn1 -t 0.5 next_key
          if [ "$next_key" = "g" ]; then
            # 'gg' - go to first result
            prev_pos=$CURRENT_POS
            CURRENT_POS=0
            # Check if we need to redraw the whole page
            if [ $((CURRENT_POS / PAGE_SIZE)) -ne $((prev_pos / PAGE_SIZE)) ]; then
              full_redraw=true
            else
              full_redraw=false
            fi
            draw_results
          fi
          ;;
      "")  # Enter key
          # Get the message ID from our stored array
          MESSAGE_ID="${MESSAGE_IDS[$CURRENT_POS]}"
          
          # Debug info - save to a file for inspection
          {
            echo "Selected position: $CURRENT_POS"
            echo "Display text: ${DISPLAY_TEXTS[$CURRENT_POS]}"
            echo "Message ID: $MESSAGE_ID"
          } > ~/.nms_debug.log
          
          clear
          tput sgr0
          evolution "mid:$MESSAGE_ID" &
          sleep 1
          full_redraw=true
          draw_results
          ;;
      q)  # Quit
          clear
          tput sgr0
          exit 0
          ;;
    esac
  done
}

# Get search query from command line arguments
QUERY="$*"

# Initialize arrays before loading results
DISPLAY_TEXTS=()
MESSAGE_IDS=()
TOTAL_RESULTS=0

# Create temporary files for IPC (Inter-Process Communication)
TEMP_DIR="/tmp/nms_$$"
mkdir -p "$TEMP_DIR"
RESULTS_FILE="$TEMP_DIR/results"
touch "$RESULTS_FILE"

# Show initial loading screen
clear
printf "Searching for '%s'... (press q to cancel)\n\n" "$QUERY"
printf "Loading results...\n"

# Create temporary files for signaling
CANCEL_FILE="$TEMP_DIR/cancel"
LOADING_COMPLETE_FILE="$TEMP_DIR/loading_complete"
rm -f "$CANCEL_FILE" "$LOADING_COMPLETE_FILE"

# Function to process a single result and add it to the display
process_result() {
  local msg_id="$1"
  # Extract just the message ID without the id: prefix
  # This is too complex a regex, it cannot be replaced with the syntax suggested
  # in SC2001.
  # shellcheck disable=SC2001
  CLEAN_ID=$(echo "$msg_id" | sed 's/^.*id://')
  MESSAGE_IDS+=("$CLEAN_ID")
  
  # Get formatted display text for this message
  FORMATTED_TEXT=$(notmuch show --format=text --entire-thread=false "id:$CLEAN_ID" | grep -m 1 "Subject:" | sed 's/Subject: //')
  
  # If subject is empty, use a placeholder
  if [ -z "$FORMATTED_TEXT" ]; then
    FORMATTED_TEXT="[No Subject]"
  fi
  
  # Get sender, date, and flags
  SENDER=$(notmuch show --format=text --entire-thread=false "id:$CLEAN_ID" | grep -m 1 "From:" | sed 's/From: //')
  DATE_RAW=$(notmuch show --format=text --entire-thread=false "id:$CLEAN_ID" | grep -m 1 "Date:" | sed 's/Date: //')
  
  # Only show a flag indicator if the message is flagged
  if notmuch search --output=tags "id:$CLEAN_ID" | grep -q "flagged"; then
    FLAGS="F"  # Flag emoji
  else
    FLAGS=""
  fi
  
  # Convert date to YYYY-MM-DD format
  # If date conversion fails, use the original date
  if ! DATE=$(date -d "$DATE_RAW" +"%Y-%m-%d" 2>/dev/null); then
    DATE="$DATE_RAW"
  fi
  
  # Make the flags "empty" if there are none to keep the column width consistent
  if [ ${#FLAGS} -eq 0 ]; then
    FLAGS=" "
  fi
  
  # Format sender to be exactly 32 characters wide (increased back to original size since flags column is smaller)
  if [ ${#SENDER} -gt 32 ]; then
    SENDER="${SENDER:0:31}…"
  else
    # Pad with spaces if shorter than 32 characters
    while [ ${#SENDER} -lt 32 ]; do
      SENDER="$SENDER "
    done
  fi
  
  # Format the display text
  DISPLAY_TEXT="$DATE $FLAGS $SENDER   $FORMATTED_TEXT"
  
  # Save this result to the results file
  echo "$CLEAN_ID|$DISPLAY_TEXT" >> "$RESULTS_FILE"
  
  # Update the display if this is the first result or every 5 results
  local count
  count=$(wc -l < "$RESULTS_FILE")
  if [ "$count" -eq 1 ] || [ "$((count % 5))" -eq 0 ]; then
    # Clear the loading message
    if [ "$count" -eq 1 ]; then
      clear
    fi
    
    # Signal the main process to update the display
    touch "$TEMP_DIR/update_display"
  fi
}

# This function is no longer needed as we handle all keypresses in the main loop

# Function to load results from the results file
load_results() {
  DISPLAY_TEXTS=()
  MESSAGE_IDS=()
  
  while IFS="|" read -r id text; do
    MESSAGE_IDS+=("$id")
    DISPLAY_TEXTS+=("$text")
  done < "$RESULTS_FILE"
  
  TOTAL_RESULTS=${#MESSAGE_IDS[@]}
}

# Start loading results in the background
{
  notmuch search --output=messages "$QUERY" | while read -r msg_id; do
    # Check if user pressed q to cancel
    if [ -f "$CANCEL_FILE" ]; then
      break
    fi
    
    # Process this result
    process_result "$msg_id"
    
    # Brief pause to allow UI updates and key checking
    sleep 0.01
  done
  
  # Signal that loading is complete
  touch "$LOADING_COMPLETE_FILE"
  
  # If no results were found, show a message and exit
  if [ ! -s "$RESULTS_FILE" ]; then
    echo "NO_RESULTS" > "$TEMP_DIR/status"
  else
    echo "COMPLETE" > "$TEMP_DIR/status"
  fi
} &

# Function to handle user input during loading
handle_loading_input() {
  local key="$1"
  case "$key" in
    j)  # Move down
        if [ $CURRENT_POS -lt $((TOTAL_RESULTS - 1)) ]; then
          prev_pos=$CURRENT_POS
          CURRENT_POS=$((CURRENT_POS + 1))
          # Check if we need to redraw the whole page
          if [ $((CURRENT_POS / PAGE_SIZE)) -ne $((prev_pos / PAGE_SIZE)) ]; then
            full_redraw=true
          else
            full_redraw=false
          fi
          draw_results
        fi
        ;;
    k)  # Move up
        if [ $CURRENT_POS -gt 0 ]; then
          prev_pos=$CURRENT_POS
          CURRENT_POS=$((CURRENT_POS - 1))
          # Check if we need to redraw the whole page
          if [ $((CURRENT_POS / PAGE_SIZE)) -ne $((prev_pos / PAGE_SIZE)) ]; then
            full_redraw=true
          else
            full_redraw=false
          fi
          draw_results
        fi
        ;;
    G)  # Go to last result
        prev_pos=$CURRENT_POS
        CURRENT_POS=$((TOTAL_RESULTS - 1))
        # Check if we need to redraw the whole page
        if [ $((CURRENT_POS / PAGE_SIZE)) -ne $((prev_pos / PAGE_SIZE)) ]; then
          full_redraw=true
        else
          full_redraw=false
        fi
        draw_results
        ;;
    g)  # First part of 'gg' command or just 'g'
        # Wait for another key press
        read -rsn1 -t 0.5 next_key
        if [ "$next_key" = "g" ]; then
          # 'gg' - go to first result
          prev_pos=$CURRENT_POS
          CURRENT_POS=0
          # Check if we need to redraw the whole page
          if [ $((CURRENT_POS / PAGE_SIZE)) -ne $((prev_pos / PAGE_SIZE)) ]; then
            full_redraw=true
          else
            full_redraw=false
          fi
          draw_results
        fi
        ;;
    "")  # Enter key
        if [ $TOTAL_RESULTS -gt 0 ]; then
          # Get the message ID from our stored array
          MESSAGE_ID="${MESSAGE_IDS[$CURRENT_POS]}"
          
          clear
          tput sgr0
          evolution "mid:$MESSAGE_ID" &
          sleep 1
          full_redraw=true
          draw_results
        fi
        ;;
    q)  # Quit
        touch "$CANCEL_FILE"
        return 1
        ;;
  esac
  return 0
}

# Monitor for keypresses and updates during loading
while [ ! -f "$LOADING_COMPLETE_FILE" ] && [ ! -f "$CANCEL_FILE" ]; do
  # Check if we need to update the display
  if [ -f "$TEMP_DIR/update_display" ]; then
    rm -f "$TEMP_DIR/update_display"
    load_results
    full_redraw=true
    draw_results
  fi
  
  # Check for user input with a short timeout
  read -rsn1 -t 0.1 key
  if [ -n "$key" ]; then
    handle_loading_input "$key" || break
  fi
  
  sleep 0.01
done

# Final load of results
load_results

# Check status
if [ -f "$TEMP_DIR/status" ]; then
  STATUS=$(cat "$TEMP_DIR/status")
  if [ "$STATUS" = "NO_RESULTS" ]; then
    clear
    echo "No results found."
    rm -rf "$TEMP_DIR"
    exit 0
  fi
fi

# If loading was cancelled, exit
if [ -f "$CANCEL_FILE" ]; then
  rm -rf "$TEMP_DIR"
  clear
  echo "Search cancelled."
  exit 0
fi

# Final redraw after all results are loaded
full_redraw=true
draw_results

# Start the interactive TUI
main_loop
